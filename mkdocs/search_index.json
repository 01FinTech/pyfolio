{
    "docs": [
        {
            "location": "/", 
            "text": "pyfolio\n\n\n\n\n\n\npyfolio is a Python library for performance and risk analysis of\nfinancial portfolios developed by\n\nQuantopian Inc\n. It works well with the\n\nZipline\n open source backtesting library.\n\n\nAt the core of pyfolio is a so-called tear sheet that consists of\nvarious individual plots that provide a comprehensive image of the\nperformance of a trading algorithm. Here is an example of a tear sheet of a returns-based analysis of the \n$FB\n stock:\n\n\n\n\nInstallation\n\n\nTo install \npyfolio\n via \npip\n issue the following command:\n\n\npip install --pre pyfolio\n\n\n\n\nFor development, clone the git repo and run \npython setup.py develop\n\nand edit the library files directly. Make sure to reload or restart\nthe IPython kernel when you make changes.\n\n\npyfolio\n has the following dependencies:\n\n numpy\n\n scipy\n\n pandas\n\n matplotlib\n\n \nseaborn\n\n\n \npymc3\n (optional)\n\n\nQuestions?\n\n\nIf you find a bug, feel free to open an issue on our github tracker.\n\n\nYou can also join our \nmailing list\n.\n\n\nContribute\n\n\nIf you want to contribute, a great place to start would be the \nhelp-wanted issues\n.\n\n\nCredits\n\n\n\n\nGus Gordon (gus@quantopian.com)\n\n\nJustin Lent (justin@quantopian.com)\n\n\nSepideh Sadeghi (sp.sadeghi@gmail.com)\n\n\nThomas Wiecki (thomas@quantopian.com)\n\n\nJessica Stauth (jstauth@quantopian.com)\n\n\nKaren Rubin (karen@quantopian.com)\n\n\nDavid Edwards (dedwards@quantopian.com)\n\n\n\n\nFor a full list of contributors, see https://github.com/quantopian/pyfolio/graphs/contributors.", 
            "title": "Overview"
        }, 
        {
            "location": "/#pyfolio", 
            "text": "pyfolio is a Python library for performance and risk analysis of\nfinancial portfolios developed by Quantopian Inc . It works well with the Zipline  open source backtesting library.  At the core of pyfolio is a so-called tear sheet that consists of\nvarious individual plots that provide a comprehensive image of the\nperformance of a trading algorithm. Here is an example of a tear sheet of a returns-based analysis of the  $FB  stock:", 
            "title": "pyfolio"
        }, 
        {
            "location": "/#installation", 
            "text": "To install  pyfolio  via  pip  issue the following command:  pip install --pre pyfolio  For development, clone the git repo and run  python setup.py develop \nand edit the library files directly. Make sure to reload or restart\nthe IPython kernel when you make changes.  pyfolio  has the following dependencies:  numpy  scipy  pandas  matplotlib   seaborn    pymc3  (optional)", 
            "title": "Installation"
        }, 
        {
            "location": "/#questions", 
            "text": "If you find a bug, feel free to open an issue on our github tracker.  You can also join our  mailing list .", 
            "title": "Questions?"
        }, 
        {
            "location": "/#contribute", 
            "text": "If you want to contribute, a great place to start would be the  help-wanted issues .", 
            "title": "Contribute"
        }, 
        {
            "location": "/#credits", 
            "text": "Gus Gordon (gus@quantopian.com)  Justin Lent (justin@quantopian.com)  Sepideh Sadeghi (sp.sadeghi@gmail.com)  Thomas Wiecki (thomas@quantopian.com)  Jessica Stauth (jstauth@quantopian.com)  Karen Rubin (karen@quantopian.com)  David Edwards (dedwards@quantopian.com)   For a full list of contributors, see https://github.com/quantopian/pyfolio/graphs/contributors.", 
            "title": "Credits"
        }, 
        {
            "location": "/single_stock_example/", 
            "text": "Single stock analysis example in pyfolio\n\n\nHere's a simple example where we produce a set of plots, called a tear sheet, for a stock.\n\n\nImport pyfolio\n\n\n%matplotlib inline\nimport pyfolio as pf\n\n\n\nFetch the daily returns for a stock\n\n\nstock_rets = pf.utils.get_symbol_rets('FB')\n\n\n\nCreate a full tear sheet for the single stock\n\n\nThis will show charts about returns and shock events. As an example, we set the first 80% of the stock's history to be in-sample, which controls the cone plot. The Bayesian tear sheet is also enabled.\n\n\npf.create_full_tear_sheet(stock_rets, backtest_days_pct=0.8, bayesian=True)\n\nEntire data start date: 2012-05-21 00:00:00\nEntire data end date: 2015-07-13 00:00:00\n\n\nOut-of-Sample Months: 7\nBacktest Months: 30\n                   Backtest  Out_of_Sample  All_History\nsortino_ratio          1.54           3.04         1.60\nomega_ratio            1.16           1.28         1.17\nmax_drawdown          -0.48          -0.09        -0.48\ncalmar_ratio           0.79           3.70         0.77\nannual_return          0.38           0.34         0.37\nstability              0.84           0.54         0.87\nsharpe_ratio           0.78           1.52         0.83\nannual_volatility      0.49           0.22         0.45\nalpha                  0.17           0.29         0.19\nbeta                   0.97           1.04         0.98\n\nWorst Drawdown Periods\n   net drawdown in %  peak date valley date recovery date duration\n0              47.90 2012-05-21  2012-09-04    2013-07-25      309\n1              22.06 2014-03-10  2014-04-28    2014-07-24       99\n2              17.34 2013-10-18  2013-11-25    2013-12-17       43\n4               9.21 2014-10-28  2014-11-19    2014-12-22       40\n3               9.20 2015-03-24  2015-05-12    2015-06-23       66\n\n\n2-sigma returns daily    -0.055\n2-sigma returns weekly   -0.111\ndtype: float64\n\nStress Events\n\n/opt/miniconda/lib/python2.7/site-packages/matplotlib/cbook.py:137: MatplotlibDeprecationWarning: The \"loc\" positional argument to legend is deprecated. Please use the \"loc\" keyword instead.\n  warnings.warn(message, mplDeprecation, stacklevel=1)\n/opt/miniconda/lib/python2.7/site-packages/theano/scan_module/scan_perform_ext.py:133: RuntimeWarning: numpy.ndarray size changed, may indicate binary incompatibility\n  from scan_perform.scan_perform import *\n\n\n\n               mean    min    max\nEZB IR Event  0.002 -0.091  0.077\nApr14         0.001 -0.052  0.073\nOct14        -0.002 -0.061  0.046\n [-----------------100%-----------------] 2000 of 2000 complete in 4.7 sec", 
            "title": "Single stock"
        }, 
        {
            "location": "/single_stock_example/#single-stock-analysis-example-in-pyfolio", 
            "text": "Here's a simple example where we produce a set of plots, called a tear sheet, for a stock.", 
            "title": "Single stock analysis example in pyfolio"
        }, 
        {
            "location": "/single_stock_example/#import-pyfolio", 
            "text": "%matplotlib inline\nimport pyfolio as pf", 
            "title": "Import pyfolio"
        }, 
        {
            "location": "/single_stock_example/#fetch-the-daily-returns-for-a-stock", 
            "text": "stock_rets = pf.utils.get_symbol_rets('FB')", 
            "title": "Fetch the daily returns for a stock"
        }, 
        {
            "location": "/single_stock_example/#create-a-full-tear-sheet-for-the-single-stock", 
            "text": "This will show charts about returns and shock events. As an example, we set the first 80% of the stock's history to be in-sample, which controls the cone plot. The Bayesian tear sheet is also enabled.  pf.create_full_tear_sheet(stock_rets, backtest_days_pct=0.8, bayesian=True)\n\nEntire data start date: 2012-05-21 00:00:00\nEntire data end date: 2015-07-13 00:00:00\n\n\nOut-of-Sample Months: 7\nBacktest Months: 30\n                   Backtest  Out_of_Sample  All_History\nsortino_ratio          1.54           3.04         1.60\nomega_ratio            1.16           1.28         1.17\nmax_drawdown          -0.48          -0.09        -0.48\ncalmar_ratio           0.79           3.70         0.77\nannual_return          0.38           0.34         0.37\nstability              0.84           0.54         0.87\nsharpe_ratio           0.78           1.52         0.83\nannual_volatility      0.49           0.22         0.45\nalpha                  0.17           0.29         0.19\nbeta                   0.97           1.04         0.98\n\nWorst Drawdown Periods\n   net drawdown in %  peak date valley date recovery date duration\n0              47.90 2012-05-21  2012-09-04    2013-07-25      309\n1              22.06 2014-03-10  2014-04-28    2014-07-24       99\n2              17.34 2013-10-18  2013-11-25    2013-12-17       43\n4               9.21 2014-10-28  2014-11-19    2014-12-22       40\n3               9.20 2015-03-24  2015-05-12    2015-06-23       66\n\n\n2-sigma returns daily    -0.055\n2-sigma returns weekly   -0.111\ndtype: float64\n\nStress Events\n\n/opt/miniconda/lib/python2.7/site-packages/matplotlib/cbook.py:137: MatplotlibDeprecationWarning: The \"loc\" positional argument to legend is deprecated. Please use the \"loc\" keyword instead.\n  warnings.warn(message, mplDeprecation, stacklevel=1)\n/opt/miniconda/lib/python2.7/site-packages/theano/scan_module/scan_perform_ext.py:133: RuntimeWarning: numpy.ndarray size changed, may indicate binary incompatibility\n  from scan_perform.scan_perform import *\n\n\n\n               mean    min    max\nEZB IR Event  0.002 -0.091  0.077\nApr14         0.001 -0.052  0.073\nOct14        -0.002 -0.061  0.046\n [-----------------100%-----------------] 2000 of 2000 complete in 4.7 sec", 
            "title": "Create a full tear sheet for the single stock"
        }, 
        {
            "location": "/zipline_algo_example/", 
            "text": "Zipline algorithm analysis example in pyfolio\n\n\nHere's an example where we run an algorithm with zipline, then produce tear sheets for that algorithm.\n\n\nImports\n\n\nImport pyfolio, along with the necessary modules for running our zipline backtest.\n\n\n%matplotlib inline\nimport pyfolio as pf\n\n\nimport numpy as np\nimport pandas as pd\n\nimport sys\nimport logbook\nimport numpy as np\nfrom datetime import datetime\nimport pytz\n\n# Import Zipline, the open source backtester\nimport zipline\nfrom zipline import TradingAlgorithm\nfrom zipline.data.loader import load_bars_from_yahoo\nfrom zipline.api import order_target, symbol, history, add_history, schedule_function, date_rules, time_rules\nfrom zipline.algorithm import TradingAlgorithm\nfrom zipline.utils.factory import load_from_yahoo\nfrom zipline.finance import commission\n\n\n\nRun our zipline algorithm\n\n\nThis algorithm can also be adjusted to execute a modified, or completely different, trading strategy.\n\n\n# Zipline trading algorithm\n# Taken from zipline.examples.olmar\nzipline_logging = logbook.NestedSetup([\n    logbook.NullHandler(level=logbook.DEBUG, bubble=True),\n    logbook.StreamHandler(sys.stdout, level=logbook.INFO),\n    logbook.StreamHandler(sys.stderr, level=logbook.ERROR),\n])\nzipline_logging.push_application()\n\nSTOCKS = ['AMD', 'CERN', 'COST', 'DELL', 'GPS', 'INTC', 'MMM']\n\n\n# On-Line Portfolio Moving Average Reversion\n\n# More info can be found in the corresponding paper:\n# http://icml.cc/2012/papers/168.pdf\ndef initialize(algo, eps=1, window_length=5):\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.add_transform('mavg', 5)\n\n    algo.set_commission(commission.PerShare(cost=0))\n\n\ndef handle_data(algo, data):\n    algo.days += 1\n    if algo.days \n algo.window_length:\n        return\n\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n\n    m = algo.m\n\n    x_tilde = np.zeros(m)\n    b = np.zeros(m)\n\n    # find relative moving average price for each asset\n    for i, sid in enumerate(algo.sids):\n        price = data[sid].price\n        # Relative mean deviation\n        x_tilde[i] = data[sid].mavg(algo.window_length) / price\n\n    ###########################\n    # Inside of OLMAR (algo 2)\n    x_bar = x_tilde.mean()\n\n    # market relative deviation\n    mark_rel_dev = x_tilde - x_bar\n\n    # Expected return with current portfolio\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = (np.linalg.norm(mark_rel_dev)) ** 2\n\n    # test for divide-by-zero case\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n\n    rebalance_portfolio(algo, data, b_norm)\n\n    # update portfolio\n    algo.b_t = b_norm\n\n\ndef rebalance_portfolio(algo, data, desired_port):\n    # rebalance portfolio\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + \\\n            algo.portfolio.cash\n\n    for i, sid in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data[sid].price\n\n    desired_amount = np.round(desired_port * positions_value / prices)\n\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n\n    for i, sid in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])\n\n\ndef simplex_projection(v, b=1):\n    \"\"\"Projection vectors to the simplex domain\n\n    Implemented according to the paper: Efficient projections onto the\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\n    Optimization Problem: min_{w}\\| w - v \\|_{2}^{2}\n    s.t. sum_{i=1}^{m}=z, w_{i}\\geq 0\n\n    Input: A vector v \\in R^{m}, and a scalar z \n 0 (default=1)\n    Output: Projection vector w\n\n    :Example:\n    \n proj = simplex_projection([.4 ,.3, -.4, .5])\n    \n print(proj)\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\n    \n print(proj.sum())\n    1.0\n\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\n    \"\"\"\n\n    v = np.asarray(v)\n    p = len(v)\n\n    # Sort v into u in descending order\n    v = (v \n 0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n\n    rho = np.where(u \n (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = (v - theta)\n    w[w \n 0] = 0\n    return w\n\nstart = datetime(2004, 1, 1, 0, 0, 0, 0, pytz.utc)\nend = datetime(2010, 1, 1, 0, 0, 0, 0, pytz.utc)\ndata = load_from_yahoo(stocks=STOCKS, indexes={}, start=start, end=end)\ndata = data.dropna()\nolmar = TradingAlgorithm(handle_data=handle_data,\n                         initialize=initialize,\n                         identifiers=STOCKS)\nbacktest = olmar.run(data)\n\nAMD\nCERN\nCOST\nDELL\nGPS\nINTC\nMMM\n[2015-07-14 20:56:01.136902] INFO: Performance: Simulated 1511 trading days out of 1511.\n[2015-07-14 20:56:01.137554] INFO: Performance: first open: 2004-01-02 14:31:00+00:00\n[2015-07-14 20:56:01.138004] INFO: Performance: last close: 2009-12-31 21:00:00+00:00\n\n\n\nExtract metrics\n\n\nGet the returns, positions, and transactions from the zipline backtest object.\n\n\nreturns, positions, transactions, gross_lev = pf.utils.extract_rets_pos_txn_from_zipline(backtest)\n\n\n\nSingle plot example\n\n\nMake one plot of the top 5 drawdown periods.\n\n\npf.plot_drawdown_periods(returns, top=5).set_xlabel('Date')\n\n/opt/miniconda/lib/python2.7/site-packages/matplotlib/cbook.py:137: MatplotlibDeprecationWarning: The \"loc\" positional argument to legend is deprecated. Please use the \"loc\" keyword instead.\n  warnings.warn(message, mplDeprecation, stacklevel=1)\n\n\n\n\n\n\nmatplotlib.text.Text at 0x7fa783b6b110\n\n\n\n\n\n\nFull tear sheet example\n\n\nCreate a full tear sheet for our algorithm. As an example, pretend the first 80% was a backtest and the last 20% was live trading.\n\n\npf.create_full_tear_sheet(returns, \n                          positions=positions, \n                          transactions=transactions,\n                          gross_lev=gross_lev, bayesian=True, backtest_days_pct=0.8)\n\nEntire data start date: 2004-01-02 00:00:00\nEntire data end date: 2009-12-31 00:00:00\n\n\nOut-of-Sample Months: 14\nBacktest Months: 57\n                   Backtest  Out_of_Sample  All_History\nsortino_ratio          0.01           3.68         0.76\nomega_ratio            1.00           1.33         1.09\nmax_drawdown          -0.53          -0.22        -0.60\ncalmar_ratio           0.00           2.64         0.21\nannual_return          0.00           0.59         0.12\nstability              0.19           0.91         0.01\nsharpe_ratio           0.00           1.70         0.48\nannual_volatility      0.23           0.35         0.25\nalpha                  0.00           0.44         0.09\nbeta                   0.84           0.80         0.81\n\nWorst Drawdown Periods\n   net drawdown in %  peak date valley date recovery date duration\n0              59.50 2007-11-06  2008-11-20           NaT      NaN\n1              22.33 2006-02-16  2006-08-31    2007-05-21      328\n2              12.52 2005-07-28  2005-10-12    2006-01-11      120\n3              11.28 2004-11-15  2005-04-28    2005-07-22      180\n4               9.44 2007-07-16  2007-08-06    2007-09-04       37\n\n\n2-sigma returns daily    -0.032\n2-sigma returns weekly   -0.065\ndtype: float64\n\nStress Events\n          mean    min    max\nLehmann -0.003 -0.044  0.044\nAug07    0.003 -0.030  0.030\nSept08  -0.006 -0.043  0.040\n2009Q1  -0.004 -0.050  0.034\n2009Q2   0.007 -0.038  0.062\n\n\nTop 10 long positions of all time (and max%)\n[2 6 1 3 0 5 4]\n[ 0.993  0.911  0.845  0.717  0.709  0.666  0.62 ]\n\n\nTop 10 short positions of all time (and max%)\n[]\n[]\n\n\nTop 10 positions of all time (and max%)\n[2 6 1 3 0 5 4]\n[ 0.993  0.911  0.845  0.717  0.709  0.666  0.62 ]\n\n\nAll positions ever held\n[2 6 1 3 0 5 4]\n[ 0.993  0.911  0.845  0.717  0.709  0.666  0.62 ]\n\n\n [-----------------100%-----------------] 2000 of 2000 complete in 5.2 sec\n\n/opt/miniconda/lib/python2.7/site-packages/theano/scan_module/scan_perform_ext.py:133: RuntimeWarning: numpy.ndarray size changed, may indicate binary incompatibility\n  from scan_perform.scan_perform import *", 
            "title": "Zipline algorithm"
        }, 
        {
            "location": "/zipline_algo_example/#zipline-algorithm-analysis-example-in-pyfolio", 
            "text": "Here's an example where we run an algorithm with zipline, then produce tear sheets for that algorithm.", 
            "title": "Zipline algorithm analysis example in pyfolio"
        }, 
        {
            "location": "/zipline_algo_example/#imports", 
            "text": "Import pyfolio, along with the necessary modules for running our zipline backtest.  %matplotlib inline\nimport pyfolio as pf\n\n\nimport numpy as np\nimport pandas as pd\n\nimport sys\nimport logbook\nimport numpy as np\nfrom datetime import datetime\nimport pytz\n\n# Import Zipline, the open source backtester\nimport zipline\nfrom zipline import TradingAlgorithm\nfrom zipline.data.loader import load_bars_from_yahoo\nfrom zipline.api import order_target, symbol, history, add_history, schedule_function, date_rules, time_rules\nfrom zipline.algorithm import TradingAlgorithm\nfrom zipline.utils.factory import load_from_yahoo\nfrom zipline.finance import commission", 
            "title": "Imports"
        }, 
        {
            "location": "/zipline_algo_example/#run-our-zipline-algorithm", 
            "text": "This algorithm can also be adjusted to execute a modified, or completely different, trading strategy.  # Zipline trading algorithm\n# Taken from zipline.examples.olmar\nzipline_logging = logbook.NestedSetup([\n    logbook.NullHandler(level=logbook.DEBUG, bubble=True),\n    logbook.StreamHandler(sys.stdout, level=logbook.INFO),\n    logbook.StreamHandler(sys.stderr, level=logbook.ERROR),\n])\nzipline_logging.push_application()\n\nSTOCKS = ['AMD', 'CERN', 'COST', 'DELL', 'GPS', 'INTC', 'MMM']\n\n\n# On-Line Portfolio Moving Average Reversion\n\n# More info can be found in the corresponding paper:\n# http://icml.cc/2012/papers/168.pdf\ndef initialize(algo, eps=1, window_length=5):\n    algo.stocks = STOCKS\n    algo.sids = [algo.symbol(symbol) for symbol in algo.stocks]\n    algo.m = len(algo.stocks)\n    algo.price = {}\n    algo.b_t = np.ones(algo.m) / algo.m\n    algo.last_desired_port = np.ones(algo.m) / algo.m\n    algo.eps = eps\n    algo.init = True\n    algo.days = 0\n    algo.window_length = window_length\n    algo.add_transform('mavg', 5)\n\n    algo.set_commission(commission.PerShare(cost=0))\n\n\ndef handle_data(algo, data):\n    algo.days += 1\n    if algo.days   algo.window_length:\n        return\n\n    if algo.init:\n        rebalance_portfolio(algo, data, algo.b_t)\n        algo.init = False\n        return\n\n    m = algo.m\n\n    x_tilde = np.zeros(m)\n    b = np.zeros(m)\n\n    # find relative moving average price for each asset\n    for i, sid in enumerate(algo.sids):\n        price = data[sid].price\n        # Relative mean deviation\n        x_tilde[i] = data[sid].mavg(algo.window_length) / price\n\n    ###########################\n    # Inside of OLMAR (algo 2)\n    x_bar = x_tilde.mean()\n\n    # market relative deviation\n    mark_rel_dev = x_tilde - x_bar\n\n    # Expected return with current portfolio\n    exp_return = np.dot(algo.b_t, x_tilde)\n    weight = algo.eps - exp_return\n    variability = (np.linalg.norm(mark_rel_dev)) ** 2\n\n    # test for divide-by-zero case\n    if variability == 0.0:\n        step_size = 0\n    else:\n        step_size = max(0, weight / variability)\n\n    b = algo.b_t + step_size * mark_rel_dev\n    b_norm = simplex_projection(b)\n    np.testing.assert_almost_equal(b_norm.sum(), 1)\n\n    rebalance_portfolio(algo, data, b_norm)\n\n    # update portfolio\n    algo.b_t = b_norm\n\n\ndef rebalance_portfolio(algo, data, desired_port):\n    # rebalance portfolio\n    desired_amount = np.zeros_like(desired_port)\n    current_amount = np.zeros_like(desired_port)\n    prices = np.zeros_like(desired_port)\n\n    if algo.init:\n        positions_value = algo.portfolio.starting_cash\n    else:\n        positions_value = algo.portfolio.positions_value + \\\n            algo.portfolio.cash\n\n    for i, sid in enumerate(algo.sids):\n        current_amount[i] = algo.portfolio.positions[sid].amount\n        prices[i] = data[sid].price\n\n    desired_amount = np.round(desired_port * positions_value / prices)\n\n    algo.last_desired_port = desired_port\n    diff_amount = desired_amount - current_amount\n\n    for i, sid in enumerate(algo.sids):\n        algo.order(sid, diff_amount[i])\n\n\ndef simplex_projection(v, b=1):\n    \"\"\"Projection vectors to the simplex domain\n\n    Implemented according to the paper: Efficient projections onto the\n    l1-ball for learning in high dimensions, John Duchi, et al. ICML 2008.\n    Implementation Time: 2011 June 17 by Bin@libin AT pmail.ntu.edu.sg\n    Optimization Problem: min_{w}\\| w - v \\|_{2}^{2}\n    s.t. sum_{i=1}^{m}=z, w_{i}\\geq 0\n\n    Input: A vector v \\in R^{m}, and a scalar z   0 (default=1)\n    Output: Projection vector w\n\n    :Example:\n      proj = simplex_projection([.4 ,.3, -.4, .5])\n      print(proj)\n    array([ 0.33333333, 0.23333333, 0. , 0.43333333])\n      print(proj.sum())\n    1.0\n\n    Original matlab implementation: John Duchi (jduchi@cs.berkeley.edu)\n    Python-port: Copyright 2013 by Thomas Wiecki (thomas.wiecki@gmail.com).\n    \"\"\"\n\n    v = np.asarray(v)\n    p = len(v)\n\n    # Sort v into u in descending order\n    v = (v   0) * v\n    u = np.sort(v)[::-1]\n    sv = np.cumsum(u)\n\n    rho = np.where(u   (sv - b) / np.arange(1, p + 1))[0][-1]\n    theta = np.max([0, (sv[rho] - b) / (rho + 1)])\n    w = (v - theta)\n    w[w   0] = 0\n    return w\n\nstart = datetime(2004, 1, 1, 0, 0, 0, 0, pytz.utc)\nend = datetime(2010, 1, 1, 0, 0, 0, 0, pytz.utc)\ndata = load_from_yahoo(stocks=STOCKS, indexes={}, start=start, end=end)\ndata = data.dropna()\nolmar = TradingAlgorithm(handle_data=handle_data,\n                         initialize=initialize,\n                         identifiers=STOCKS)\nbacktest = olmar.run(data)\n\nAMD\nCERN\nCOST\nDELL\nGPS\nINTC\nMMM\n[2015-07-14 20:56:01.136902] INFO: Performance: Simulated 1511 trading days out of 1511.\n[2015-07-14 20:56:01.137554] INFO: Performance: first open: 2004-01-02 14:31:00+00:00\n[2015-07-14 20:56:01.138004] INFO: Performance: last close: 2009-12-31 21:00:00+00:00", 
            "title": "Run our zipline algorithm"
        }, 
        {
            "location": "/zipline_algo_example/#extract-metrics", 
            "text": "Get the returns, positions, and transactions from the zipline backtest object.  returns, positions, transactions, gross_lev = pf.utils.extract_rets_pos_txn_from_zipline(backtest)", 
            "title": "Extract metrics"
        }, 
        {
            "location": "/zipline_algo_example/#single-plot-example", 
            "text": "Make one plot of the top 5 drawdown periods.  pf.plot_drawdown_periods(returns, top=5).set_xlabel('Date')\n\n/opt/miniconda/lib/python2.7/site-packages/matplotlib/cbook.py:137: MatplotlibDeprecationWarning: The \"loc\" positional argument to legend is deprecated. Please use the \"loc\" keyword instead.\n  warnings.warn(message, mplDeprecation, stacklevel=1) matplotlib.text.Text at 0x7fa783b6b110", 
            "title": "Single plot example"
        }, 
        {
            "location": "/zipline_algo_example/#full-tear-sheet-example", 
            "text": "Create a full tear sheet for our algorithm. As an example, pretend the first 80% was a backtest and the last 20% was live trading.  pf.create_full_tear_sheet(returns, \n                          positions=positions, \n                          transactions=transactions,\n                          gross_lev=gross_lev, bayesian=True, backtest_days_pct=0.8)\n\nEntire data start date: 2004-01-02 00:00:00\nEntire data end date: 2009-12-31 00:00:00\n\n\nOut-of-Sample Months: 14\nBacktest Months: 57\n                   Backtest  Out_of_Sample  All_History\nsortino_ratio          0.01           3.68         0.76\nomega_ratio            1.00           1.33         1.09\nmax_drawdown          -0.53          -0.22        -0.60\ncalmar_ratio           0.00           2.64         0.21\nannual_return          0.00           0.59         0.12\nstability              0.19           0.91         0.01\nsharpe_ratio           0.00           1.70         0.48\nannual_volatility      0.23           0.35         0.25\nalpha                  0.00           0.44         0.09\nbeta                   0.84           0.80         0.81\n\nWorst Drawdown Periods\n   net drawdown in %  peak date valley date recovery date duration\n0              59.50 2007-11-06  2008-11-20           NaT      NaN\n1              22.33 2006-02-16  2006-08-31    2007-05-21      328\n2              12.52 2005-07-28  2005-10-12    2006-01-11      120\n3              11.28 2004-11-15  2005-04-28    2005-07-22      180\n4               9.44 2007-07-16  2007-08-06    2007-09-04       37\n\n\n2-sigma returns daily    -0.032\n2-sigma returns weekly   -0.065\ndtype: float64\n\nStress Events\n          mean    min    max\nLehmann -0.003 -0.044  0.044\nAug07    0.003 -0.030  0.030\nSept08  -0.006 -0.043  0.040\n2009Q1  -0.004 -0.050  0.034\n2009Q2   0.007 -0.038  0.062\n\n\nTop 10 long positions of all time (and max%)\n[2 6 1 3 0 5 4]\n[ 0.993  0.911  0.845  0.717  0.709  0.666  0.62 ]\n\n\nTop 10 short positions of all time (and max%)\n[]\n[]\n\n\nTop 10 positions of all time (and max%)\n[2 6 1 3 0 5 4]\n[ 0.993  0.911  0.845  0.717  0.709  0.666  0.62 ]\n\n\nAll positions ever held\n[2 6 1 3 0 5 4]\n[ 0.993  0.911  0.845  0.717  0.709  0.666  0.62 ]\n\n\n [-----------------100%-----------------] 2000 of 2000 complete in 5.2 sec\n\n/opt/miniconda/lib/python2.7/site-packages/theano/scan_module/scan_perform_ext.py:133: RuntimeWarning: numpy.ndarray size changed, may indicate binary incompatibility\n  from scan_perform.scan_perform import *", 
            "title": "Full tear sheet example"
        }
    ]
}